((3) 0 () 2 ((p+ #"E:\\Documents\\Racket\\Gnaily-s-blog\\_src\\posts\\2018-04-06-\347\256\200\346\230\216SQL.md" . windows) (p+ #"E:\\Documents\\Racket\\Gnaily-s-blog\\_src\\posts\\2018-09-30-spring-framwork.md" . windows)) () (h ! (equal) ((? . 0) f post (u . "简明SQL") (? . 0) 1549209491 (p+ #"E:\\Documents\\Racket\\Gnaily-s-blog\\2018/04/\347\256\200\346\230\216sql.html" . windows) (u . "/2018\\04\\%E7%AE%80%E6%98%8Esql.html") (u . "2018-04-06T00:00:00") #f (? . 1) (c (u . "SQL")) (u . "\n<p>[TOC]</p>\n\n<h3 id=\"表结构操作\">表结构操作</h3>\n\n<p>查看表结构</p>\n\n<div class=\"brush: sql\">\n <pre><code>desc  tablename ; -- 查看表tablename的结构信息</code></pre></div>\n\n<p>创建表结构</p>\n\n<div class=\"brush: sql\">\n <pre><code>CREATE TABLE tablename(\n  -- db_data_type是数据库的数据类型，比如int(5)，varchar(64)\n  column_name_1   db_data_type\n  column_name_2   db_data_type\n  ...\n  column_name_n   db_data_type \n) ;</code></pre></div>\n\n<p>增加表的字段</p>\n\n<div class=\"brush: sql\">\n <pre><code>alter tablename\n-- db_data_type是数据库的数据类型，比如int()，varchar(64)\nadd   column_name_1   db_data_type\nadd   column_name_2   db_data_type\n...\nadd   column_name_n   db_data_type ; </code></pre></div>\n\n<p>删除表的字段</p>\n\n<div class=\"brush: sql\">\n <pre><code>alter tablename\ndrop  column column_name_1  \ndrop  column column_name_2\n...\ndrop  column column_name_n ;</code></pre></div>\n\n<p>删除表</p>\n\n<div class=\"brush: sql\">\n <pre><code>drop tablename ;</code></pre></div>\n\n<p>创建索引：</p>\n\n<div class=\"brush: sql\">\n <pre><code>-- 在table_name表的column_name列上创建一个简单的索引。允许使用重复的索引值。\ncreate index index_name\non tablename (column_name) ;\n \n-- 在table_name表的column_name列上创建一个唯一的索引。唯一的索引意味着任意两个行不能拥有相同的索引值。\ncreate uinqe index index_name\non tablename (column_name) ;</code></pre></div>\n\n<h3 id=\"检索数据select\">检索数据select</h3>\n\n<p>数据检索SQL一般由select子句，from子句，join子句、where子句、group by子句、having子句 、order by子句组成。from子句后的其他子句不是必须要有的，根据实际需要进行使用。各个子句出现的相对顺序不能颠倒。Select检索数据的<code>逻辑</code>处理流程为：</p>\n\n<p>join连接表&mdash;&gt;where 对行过滤&mdash;&gt;group by分组&mdash;&gt;having对组过滤&mdash;&gt;聚集函数处理&mdash;&gt;order by排序&mdash;&gt;输出结果。</p>\n\n<p>当有子查询时先处理内层子查询，再处理外层查询。</p>\n\n<div class=\"brush: sql\">\n <pre><code>select\n   列名 -- 多个列名用逗号隔开，非聚集列（没有被聚集函数作用的列）必须是分组列名的子集\nfrom\n   表名\nleft|right|inner  join   表名   on   关联条件\nwhere  \n   过滤行条件\ngroup by  \n   分组列名  -- 多个列名用逗号隔开\nhaving\n   过滤分组条件  -- 过滤分组条件中的非聚集列（没有被聚集函数作用的列）必须是分组列名的子集\norder by\n   排序字段</code></pre></div>\n\n<p>简单检索SQL</p>\n\n<div class=\"brush: sql\">\n <pre><code>-- 检索tablename表的所有列的结果\nselect *  from tablename;\n-- 检索tablename表的指定列的结果\nselect column_name_1,column_name_2,... column_name_n from tablename; </code></pre></div>\n\n<p>过滤行使用where</p>\n\n<p>where关系运算符：</p>\n\n<ul>\n <li>大于( &gt;）:只检索出满足指定字段大于指定值的数据，其余被过滤掉。</li>\n <li>小于（&lt;）：只检索出满足指定字段小于指定值的数据，其余被过滤掉</li>\n <li>等于（=）：只检索出满足指定字段等于指定值的数据，其余被过滤掉</li>\n <li>大于或等于（&gt;=）:只检索出满足指定字段大于或等于指定值的数据，其余被过滤掉</li>\n <li>小于或等于（&lt;=）:只检索出满足指定字段小于或等于指定值的数据，其余被过滤掉</li>\n <li>不等于（&lt;&gt;或！=）：只检索出满足指定字段不等于指定值的数据，其余被过滤掉</li>\n <li>in操作符：只检索出满足指定字段在指定数据集合里的数据，其余被过滤掉</li>\n <li>like通配匹配符：只检索出满足指定字段能与like后跟的搜索模式匹配的数据，其余被过滤掉</li>\n <li>百分号通配符（%）：匹配任意字符出现任意次数。可以用在搜索模式的开始、中间和结尾处。</li>\n <li>下划线通配符（_）:只匹配单个字符</li>\n <li>方括号通配符（[ ]）：方括号通配符里用于指定一个字符集， 只匹配出一个在该字符集里的字符。</li>\n <li>and操作符：组合多个条件，检索出同时满足多个条件的数据</li>\n <li>or操作符：组合多个条件，检索出满足条件之一的数据</li></ul>\n\n<div class=\"brush: sql\">\n <pre><code>-- useage:\nwhere\n    column_name_1=value1\nand column_name_2&gt;value2\nand column_name_3 in ('张三'，'李四')\n    -- 匹配end结尾的字符串\nand column_name_4 like '%end' </code></pre></div>\n\n<p>检索结果分组用group by</p>\n\n<p>group by关键字指示DBMS对指定列中数据都相同的分为一组，group by 后的列相当分组的维度。</p>\n\n<ul>\n <li>group by 可以包含任意数目的列</li>\n <li>group by 子句中列出的每个列都必须是检索列或有效表达式（不能是聚集函数）。如果select 中使用列表达式，group by 中也要是表达式而不能是表达式的别名。</li>\n <li>除进行聚集计算的列外，select中的每个列必须是group by中给出的列。</li>\n <li>分组列中如果有null值，则列的所有null值将分为一个组</li></ul>\n\n<div class=\"brush: sql\">\n <pre><code>-- useage:\nselect\n    -- select输出的列必须是group by中的列\n    column_name_1,column_name_2 \nfrom\n    tablename\ngroup by\n    -- 检索数据中这几个分组列的各个列的值相同的分为一组\n    column_name_1,column_name_2,column_name_3 ;</code></pre></div>\n\n<p>过滤检索结果中的分组用having</p>\n\n<p>where对行进行过滤，having则对组进行过滤。having支持所有where子句中的操作符号。由于where在对数据分组前进数据行过滤，having则在分组后进行组的过滤，所以where排除的行不会包含在分组中，having过滤条件的字段必须是group by 中的字段。where中不能包含聚集函数，而having中可以包含聚集函数。</p>\n\n<div class=\"brush: sql\">\n <pre><code>-- useage:\nselect\n    -- select输出的列必须是group by中的列\n    column_name_1,column_name_2 \nfrom\n    tablename\ngroup by\n    -- 检索数据中这几个分组列的各个列的值相同的分为一组\n    column_name_1,column_name_2,column_name_3\nhaving\n      column_name_1=value1\n  and column_name_2&gt;value2 ; </code></pre></div>\n\n<p>排序检索结果用order by</p>\n\n<div class=\"brush: sql\">\n <pre><code>select\n    column_name_1,column_name_2,column_name_3,column_name_4 \nfrom\n    tablename\norder by\n    column_name_2 desc,column_name_3 asc ;</code></pre></div>\n\n<p>汇总检索结果使用聚集函数</p>\n\n<p>聚集函数：运行在列的分组上，返回单个值的函数。如果有进行分组，聚集函数在分组后进行聚集</p>\n\n<p>常用聚集函数：</p>\n\n<ul>\n <li>AVG（column）：返回指定列的均值</li>\n <li>COUNT（column）：返回指定列的值的数目</li>\n <li>MAX（column）：返回指定列的最大值</li>\n <li>MIN（column）：返回指定列的最大值</li>\n <li>SUM（column）：返回指定列值之和</li></ul>\n\n<p>聚集函数参数：聚集函数作用的的列名前可以加上distinct或all参数。all为默认参数，聚集函数作用的的列名前不加参数时默认为all，会对指定列的所用行进行计算，如果聚集函数作用的的列名前加上distinct参数，只会对指定列的不同值进行计算。有些数据库并不支持distinct。</p>\n\n<div class=\"brush: sql\">\n <pre><code>-- useage:\nselect\n    -- select输出的非聚集列必须是group by中的列\n    AVG(column_name_1) ,\n    COUNT(column_name_2) ,\n    MAX(column_name_3)\n    SUM(column_name_5),\n    column_name_6,\n    column_name_7\nfrom\n    tablename\nwhere\n    \tcolumn_name_1=value1\n\tand column_name_2&gt;value2\ngroup by\n    -- 检索数据中这几个分组列的各个列的值相同的分为一组\n    column_name_6,\n    column_name_7\n    column_name_8\nhaving\n      MIN(column_name_4)=value ;</code></pre></div>\n\n<p>关联查询用join&hellip;on&hellip;</p>\n\n<p>关联查询中的笛卡尔积</p>\n\n<p>左连接left join right-table on&hellip;:包含左表的所有记录甚至是右表中没有和它匹配的记录。</p>\n\n<p>右连接right join right-table on&hellip;:包含右表的所有记录甚至是左表中没有和它匹配的记录。</p>\n\n<p>内连接inner join&hellip;.on&hellip; :又称之为等值连接。仅仅选出两张表中互相匹配的记录</p>\n\n<p>关联查询耗资源，不要连接不必要的表。</p>\n\n<p>关联查询与子查询可转换。</p>\n\n<p>自连接：</p>\n\n<p>全外部连接</p>\n\n<div class=\"brush: sql\">\n <pre><code>-- useage\n </code></pre></div>\n\n<p>组合查询使用union</p>\n\n<p>union 操作符用于合并两个或多个 select 语句的结果集，要求select 子句的列的数据类型相似。</p>\n\n<ul>\n <li>\n  <p>多个查询中从不同表返回类似结构数据</p></li>\n <li>\n  <p>对单个表执行多个查询，按单个表返回查询数据</p></li></ul>\n\n<p>union的结果不包含重复值，union all的结果包含重复值。</p>\n\n<div class=\"brush: sql\">\n <pre><code>-- useage\n </code></pre></div>\n\n<p>子查询：嵌套在其他查询中的完整查询语句，可以嵌套的地方有</p>\n\n<ul>\n <li>把子查询用作返回列</li>\n <li>把子查询用作where条件</li></ul>\n\n<p>子查询总是从内向外处理。做为子查询的select语句只能查询单个列。</p>\n\n<h3 id=\"插入数据insert\">插入数据insert</h3>\n\n<p>插入一行数据</p>\n\n<div class=\"brush: sql\">\n <pre><code>insert into tablename (column_name_1,column_name_2, ... column_name_n) values(value1,value2, ... valuen );</code></pre></div>\n\n<p>插入从表中检索出来的数据（可以是多行）insert into..select&hellip;</p>\n\n<div class=\"brush: sql\">\n <pre><code>insert into  tablename (column_name_1,column_name_2, ... column_name_n)\n-- 这里是一条检索数据的sql\nselect column_name_1,column_name_2, ... column_name_n from ....  ;</code></pre></div>\n\n<p>复制数据到一个表中 select &hellip;into&hellip;</p>\n\n<div class=\"brush: sql\">\n <pre><code>-- useage:\nselect column_name_1,column_name_2, ... column_name_n into tablename\nfrom tablename\n[left join ...  on ... ]\n[where ... ]\n[group by ... ]\n[having ... ]\n[order by ... ]</code></pre></div>\n\n<h3 id=\"更新数据update\">更新数据update</h3>\n\n<p>使用where条件限定需要更新的行，省略where将更新整个表。编写时需要注意where条件的正确性，避免误操作。</p>\n\n<div class=\"brush: sql\">\n <pre><code>-- 更新满足where限定条件的行，省略where将更新表的所有行\nupdate\n  tablename \nset\n  column_name_1=value1 ,\n  column_name_2=value2,\n  ...\n  column_name_n=valuen\nwhere ...;</code></pre></div>\n\n<h3 id=\"删除数据delete\">删除数据delete</h3>\n\n<p>使用where条件限定需要删除的行，省略where将删除整个表的数据。编写时需要注意where条件的正确性，避免误操作。</p>\n\n<div class=\"brush: sql\">\n <pre><code>-- 从tablename表删除满足where条件的行，省略where时将删除改表的所有数据\ndelete from tablename  where ... ;</code></pre></div>\n\n<h3 id=\"sql优化思路\">SQL优化思路</h3>\n\n<ul>\n <li>优化select子句</li></ul>\n\n<p> 用需要查询列的名字代替通配符*。使用SELECT <em>时一方面数据库需要去查询表的元数据来将</em> 解析为表的具体字段， 另一方面会查询出表所有列的数据，而有的列的数据我们并不需要。这两者都会造成执行效率的下降。</p>\n\n<ul>\n <li>\n  <p>优化join子句</p></li>\n <li>\n  <p>优化where子句</p></li></ul>\n\n<p> 优化or条件：对于含有or的查询子句，如果要利用索引，则or之间的每个条件都必须要用到索引；如果没有索引则需要考虑增加索引。</p>\n\n<p> 优化or为union查询。</p>\n\n<ul>\n <li>\n  <p>优化子查询为关联查询：join之所以比子查询更有效率是因为其不需要建立临时表来完成这个需要多个查询步骤的工作。</p></li>\n <li>\n  <p>使用SQL hint ：在SQL中人为加入提示来达到优化操作的目的。</p></li></ul>") #f (u . "\n<p>[TOC]</p>\n\n<h3 id=\"表结构操作\">表结构操作</h3>\n\n<p>查看表结构</p>\n\n<div class=\"brush: sql\">\n <pre><code>desc  tablename ; -- 查看表tablename的结构信息</code></pre></div>\n\n<p>创建表结构</p>\n\n<div class=\"brush: sql\">\n <pre><code>CREATE TABLE tablename(\n  -- db_data_type是数据库的数据类型，比如int(5)，varchar(64)\n  column_name_1   db_data_type\n  column_name_2   db_data_type\n  ...\n  column_name_n   db_data_type \n) ;</code></pre></div>\n\n<p>增加表的字段</p>\n\n<div class=\"brush: sql\">\n <pre><code>alter tablename\n-- db_data_type是数据库的数据类型，比如int()，varchar(64)\nadd   column_name_1   db_data_type\nadd   column_name_2   db_data_type\n...\nadd   column_name_n   db_data_type ; </code></pre></div>\n\n<p>删除表的字段</p>\n\n<div class=\"brush: sql\">\n <pre><code>alter tablename\ndrop  column column_name_1  \ndrop  column column_name_2\n...\ndrop  column column_name_n ;</code></pre></div>\n\n<p>删除表</p>\n\n<div class=\"brush: sql\">\n <pre><code>drop tablename ;</code></pre></div>\n\n<p>创建索引：</p>\n\n<div class=\"brush: sql\">\n <pre><code>-- 在table_name表的column_name列上创建一个简单的索引。允许使用重复的索引值。\ncreate index index_name\non tablename (column_name) ;\n \n-- 在table_name表的column_name列上创建一个唯一的索引。唯一的索引意味着任意两个行不能拥有相同的索引值。\ncreate uinqe index index_name\non tablename (column_name) ;</code></pre></div>\n\n<h3 id=\"检索数据select\">检索数据select</h3>\n\n<p>数据检索SQL一般由select子句，from子句，join子句、where子句、group by子句、having子句 、order by子句组成。from子句后的其他子句不是必须要有的，根据实际需要进行使用。各个子句出现的相对顺序不能颠倒。Select检索数据的<code>逻辑</code>处理流程为：</p>\n\n<p>join连接表&mdash;&gt;where 对行过滤&mdash;&gt;group by分组&mdash;&gt;having对组过滤&mdash;&gt;聚集函数处理&mdash;&gt;order by排序&mdash;&gt;输出结果。</p>\n\n<p>当有子查询时先处理内层子查询，再处理外层查询。</p>\n\n<div class=\"brush: sql\">\n <pre><code>select\n   列名 -- 多个列名用逗号隔开，非聚集列（没有被聚集函数作用的列）必须是分组列名的子集\nfrom\n   表名\nleft|right|inner  join   表名   on   关联条件\nwhere  \n   过滤行条件\ngroup by  \n   分组列名  -- 多个列名用逗号隔开\nhaving\n   过滤分组条件  -- 过滤分组条件中的非聚集列（没有被聚集函数作用的列）必须是分组列名的子集\norder by\n   排序字段</code></pre></div>\n\n<p>简单检索SQL</p>\n\n<div class=\"brush: sql\">\n <pre><code>-- 检索tablename表的所有列的结果\nselect *  from tablename;\n-- 检索tablename表的指定列的结果\nselect column_name_1,column_name_2,... column_name_n from tablename; </code></pre></div>\n\n<p>过滤行使用where</p>\n\n<p>where关系运算符：</p>\n\n<ul>\n <li>大于( &gt;）:只检索出满足指定字段大于指定值的数据，其余被过滤掉。</li>\n <li>小于（&lt;）：只检索出满足指定字段小于指定值的数据，其余被过滤掉</li>\n <li>等于（=）：只检索出满足指定字段等于指定值的数据，其余被过滤掉</li>\n <li>大于或等于（&gt;=）:只检索出满足指定字段大于或等于指定值的数据，其余被过滤掉</li>\n <li>小于或等于（&lt;=）:只检索出满足指定字段小于或等于指定值的数据，其余被过滤掉</li>\n <li>不等于（&lt;&gt;或！=）：只检索出满足指定字段不等于指定值的数据，其余被过滤掉</li>\n <li>in操作符：只检索出满足指定字段在指定数据集合里的数据，其余被过滤掉</li>\n <li>like通配匹配符：只检索出满足指定字段能与like后跟的搜索模式匹配的数据，其余被过滤掉</li>\n <li>百分号通配符（%）：匹配任意字符出现任意次数。可以用在搜索模式的开始、中间和结尾处。</li>\n <li>下划线通配符（_）:只匹配单个字符</li>\n <li>方括号通配符（[ ]）：方括号通配符里用于指定一个字符集， 只匹配出一个在该字符集里的字符。</li>\n <li>and操作符：组合多个条件，检索出同时满足多个条件的数据</li>\n <li>or操作符：组合多个条件，检索出满足条件之一的数据</li></ul>\n\n<div class=\"brush: sql\">\n <pre><code>-- useage:\nwhere\n    column_name_1=value1\nand column_name_2&gt;value2\nand column_name_3 in ('张三'，'李四')\n    -- 匹配end结尾的字符串\nand column_name_4 like '%end' </code></pre></div>\n\n<p>检索结果分组用group by</p>\n\n<p>group by关键字指示DBMS对指定列中数据都相同的分为一组，group by 后的列相当分组的维度。</p>\n\n<ul>\n <li>group by 可以包含任意数目的列</li>\n <li>group by 子句中列出的每个列都必须是检索列或有效表达式（不能是聚集函数）。如果select 中使用列表达式，group by 中也要是表达式而不能是表达式的别名。</li>\n <li>除进行聚集计算的列外，select中的每个列必须是group by中给出的列。</li>\n <li>分组列中如果有null值，则列的所有null值将分为一个组</li></ul>\n\n<div class=\"brush: sql\">\n <pre><code>-- useage:\nselect\n    -- select输出的列必须是group by中的列\n    column_name_1,column_name_2 \nfrom\n    tablename\ngroup by\n    -- 检索数据中这几个分组列的各个列的值相同的分为一组\n    column_name_1,column_name_2,column_name_3 ;</code></pre></div>\n\n<p>过滤检索结果中的分组用having</p>\n\n<p>where对行进行过滤，having则对组进行过滤。having支持所有where子句中的操作符号。由于where在对数据分组前进数据行过滤，having则在分组后进行组的过滤，所以where排除的行不会包含在分组中，having过滤条件的字段必须是group by 中的字段。where中不能包含聚集函数，而having中可以包含聚集函数。</p>\n\n<div class=\"brush: sql\">\n <pre><code>-- useage:\nselect\n    -- select输出的列必须是group by中的列\n    column_name_1,column_name_2 \nfrom\n    tablename\ngroup by\n    -- 检索数据中这几个分组列的各个列的值相同的分为一组\n    column_name_1,column_name_2,column_name_3\nhaving\n      column_name_1=value1\n  and column_name_2&gt;value2 ; </code></pre></div>\n\n<p>排序检索结果用order by</p>\n\n<div class=\"brush: sql\">\n <pre><code>select\n    column_name_1,column_name_2,column_name_3,column_name_4 \nfrom\n    tablename\norder by\n    column_name_2 desc,column_name_3 asc ;</code></pre></div>\n\n<p>汇总检索结果使用聚集函数</p>\n\n<p>聚集函数：运行在列的分组上，返回单个值的函数。如果有进行分组，聚集函数在分组后进行聚集</p>\n\n<p>常用聚集函数：</p>\n\n<ul>\n <li>AVG（column）：返回指定列的均值</li>\n <li>COUNT（column）：返回指定列的值的数目</li>\n <li>MAX（column）：返回指定列的最大值</li>\n <li>MIN（column）：返回指定列的最大值</li>\n <li>SUM（column）：返回指定列值之和</li></ul>\n\n<p>聚集函数参数：聚集函数作用的的列名前可以加上distinct或all参数。all为默认参数，聚集函数作用的的列名前不加参数时默认为all，会对指定列的所用行进行计算，如果聚集函数作用的的列名前加上distinct参数，只会对指定列的不同值进行计算。有些数据库并不支持distinct。</p>\n\n<div class=\"brush: sql\">\n <pre><code>-- useage:\nselect\n    -- select输出的非聚集列必须是group by中的列\n    AVG(column_name_1) ,\n    COUNT(column_name_2) ,\n    MAX(column_name_3)\n    SUM(column_name_5),\n    column_name_6,\n    column_name_7\nfrom\n    tablename\nwhere\n    \tcolumn_name_1=value1\n\tand column_name_2&gt;value2\ngroup by\n    -- 检索数据中这几个分组列的各个列的值相同的分为一组\n    column_name_6,\n    column_name_7\n    column_name_8\nhaving\n      MIN(column_name_4)=value ;</code></pre></div>\n\n<p>关联查询用join&hellip;on&hellip;</p>\n\n<p>关联查询中的笛卡尔积</p>\n\n<p>左连接left join right-table on&hellip;:包含左表的所有记录甚至是右表中没有和它匹配的记录。</p>\n\n<p>右连接right join right-table on&hellip;:包含右表的所有记录甚至是左表中没有和它匹配的记录。</p>\n\n<p>内连接inner join&hellip;.on&hellip; :又称之为等值连接。仅仅选出两张表中互相匹配的记录</p>\n\n<p>关联查询耗资源，不要连接不必要的表。</p>\n\n<p>关联查询与子查询可转换。</p>\n\n<p>自连接：</p>\n\n<p>全外部连接</p>\n\n<div class=\"brush: sql\">\n <pre><code>-- useage\n </code></pre></div>\n\n<p>组合查询使用union</p>\n\n<p>union 操作符用于合并两个或多个 select 语句的结果集，要求select 子句的列的数据类型相似。</p>\n\n<ul>\n <li>\n  <p>多个查询中从不同表返回类似结构数据</p></li>\n <li>\n  <p>对单个表执行多个查询，按单个表返回查询数据</p></li></ul>\n\n<p>union的结果不包含重复值，union all的结果包含重复值。</p>\n\n<div class=\"brush: sql\">\n <pre><code>-- useage\n </code></pre></div>\n\n<p>子查询：嵌套在其他查询中的完整查询语句，可以嵌套的地方有</p>\n\n<ul>\n <li>把子查询用作返回列</li>\n <li>把子查询用作where条件</li></ul>\n\n<p>子查询总是从内向外处理。做为子查询的select语句只能查询单个列。</p>\n\n<h3 id=\"插入数据insert\">插入数据insert</h3>\n\n<p>插入一行数据</p>\n\n<div class=\"brush: sql\">\n <pre><code>insert into tablename (column_name_1,column_name_2, ... column_name_n) values(value1,value2, ... valuen );</code></pre></div>\n\n<p>插入从表中检索出来的数据（可以是多行）insert into..select&hellip;</p>\n\n<div class=\"brush: sql\">\n <pre><code>insert into  tablename (column_name_1,column_name_2, ... column_name_n)\n-- 这里是一条检索数据的sql\nselect column_name_1,column_name_2, ... column_name_n from ....  ;</code></pre></div>\n\n<p>复制数据到一个表中 select &hellip;into&hellip;</p>\n\n<div class=\"brush: sql\">\n <pre><code>-- useage:\nselect column_name_1,column_name_2, ... column_name_n into tablename\nfrom tablename\n[left join ...  on ... ]\n[where ... ]\n[group by ... ]\n[having ... ]\n[order by ... ]</code></pre></div>\n\n<h3 id=\"更新数据update\">更新数据update</h3>\n\n<p>使用where条件限定需要更新的行，省略where将更新整个表。编写时需要注意where条件的正确性，避免误操作。</p>\n\n<div class=\"brush: sql\">\n <pre><code>-- 更新满足where限定条件的行，省略where将更新表的所有行\nupdate\n  tablename \nset\n  column_name_1=value1 ,\n  column_name_2=value2,\n  ...\n  column_name_n=valuen\nwhere ...;</code></pre></div>\n\n<h3 id=\"删除数据delete\">删除数据delete</h3>\n\n<p>使用where条件限定需要删除的行，省略where将删除整个表的数据。编写时需要注意where条件的正确性，避免误操作。</p>\n\n<div class=\"brush: sql\">\n <pre><code>-- 从tablename表删除满足where条件的行，省略where时将删除改表的所有数据\ndelete from tablename  where ... ;</code></pre></div>\n\n<h3 id=\"sql优化思路\">SQL优化思路</h3>\n\n<ul>\n <li>优化select子句</li></ul>\n\n<p> 用需要查询列的名字代替通配符*。使用SELECT <em>时一方面数据库需要去查询表的元数据来将</em> 解析为表的具体字段， 另一方面会查询出表所有列的数据，而有的列的数据我们并不需要。这两者都会造成执行效率的下降。</p>\n\n<ul>\n <li>\n  <p>优化join子句</p></li>\n <li>\n  <p>优化where子句</p></li></ul>\n\n<p> 优化or条件：对于含有or的查询子句，如果要利用索引，则or之间的每个条件都必须要用到索引；如果没有索引则需要考虑增加索引。</p>\n\n<p> 优化or为union查询。</p>\n\n<ul>\n <li>\n  <p>优化子查询为关联查询：join之所以比子查询更有效率是因为其不需要建立临时表来完成这个需要多个查询步骤的工作。</p></li>\n <li>\n  <p>使用SQL hint ：在SQL中人为加入提示来达到优化操作的目的。</p></li></ul>")) ((? . 1) f post (u . "Spring Framework") (? . 1) 1549209430 (p+ #"E:\\Documents\\Racket\\Gnaily-s-blog\\2018/09/spring-framework.html" . windows) (u . "/2018\\09\\spring-framework.html") (u . "2018-09-01T00:00:00") (? . 0) #f (c (u . "Web") c (u . "Spring")) (u . "\n<p>[TOC]</p>\n\n<h1 id=\"spring\">Spring</h1>\n\n<blockquote>\n <p>Spring 参考文档</p>\n <p>Spring core</p>\n <p>https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html</p>\n <p>Spring mvc</p></blockquote>\n\n<p>Sping将程序看成由各个组件相互组装而成，<code>抽象出组件和组装组件的容器</code>。应用程序中通过组件的配置信息（xml、java注解、java代码）告诉容器如何初始化、配置和组件组件，Spring扫描配置信息，然后按照配置信息组装出程序。这就是Spring的核心原理。</p>\n\n<div class=\"figure\"><img src=\"C:UsersGnailyAppDataLocalTemp1523797001169.png\" alt=\"1523797001169\" />\n <p class=\"caption\">1523797001169</p></div>\n\n<h3 id=\"应用程序组件的表示spring-bean\">应用程序组件的表示——Spring Bean</h3>\n\n<p>Spring使用Bean来表示应用程序组件，在Spring中每一个应用程序组件都是一个Bean实体。Spring的Bean可以是任何形式的POJO。</p>\n\n<p>Bean的作用域：</p>\n\n<p>| Scope | Description | | &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; | &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; | | <a href=\"https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-singleton\">singleton</a> | (Default) Scopes a single bean definition to a single object instance per Spring IoC container. | | <a href=\"https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-prototype\">prototype</a> | Scopes a single bean definition to any number of object instances. | | <a href=\"https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-request\">request</a> | Scopes a single bean definition to the lifecycle of a single HTTP request; that is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>. | | <a href=\"https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-session\">session</a> | Scopes a single bean definition to the lifecycle of an HTTP <code>Session</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>. | | <a href=\"https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-application\">application</a> | Scopes a single bean definition to the lifecycle of a <code>ServletContext</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>. | | <a href=\"https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/web.html#websocket-stomp-websocket-scope\">websocket</a> | Scopes a single bean definition to the lifecycle of a <code>WebSocket</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>. |</p>\n\n<p>Bean的配置：</p>\n\n<p>xml配置Bean：在xml文件中配置一个Bean时，用一个唯一的id来标识这个Bean,用class指定该Bean的类的全限定名（包名.类名）。</p>\n\n<div class=\"brush: xml\">\n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;\n \n    &lt;bean id=\"...\" class=\"...\"&gt;\n        &lt;!-- collaborators and configuration for this bean go here --&gt;\n    &lt;/bean&gt;\n \n    &lt;bean id=\"...\" class=\"...\"&gt;\n        &lt;!-- collaborators and configuration for this bean go here --&gt;\n \n    &lt;!-- more bean definitions go here --&gt;\n \n&lt;/beans&gt;</code></pre></div>\n\n<p>注解配置Bean：在POJO的类上添加@Bean注解。</p>\n\n<h3 id=\"应用程序组件的组装spring-依赖注入与控制反转\">应用程序组件的组装——Spring 依赖注入与控制反转</h3>\n\n<h4 id=\"依赖注入dependency-injection\">依赖注入（Dependency Injection）</h4>\n\n<p>一个对象不在自己的内部构造出它所依赖的对象，它所依赖的对象由第三方构造然后通过该对象的<code>构造方法</code>或者<code>setter方法</code>注入进来。</p>\n\n<h4 id=\"控制反转容器ioc-container\">控制反转容器（IoC Container）</h4>\n\n<p>Spring通过一个容器来根据一个对象的配置信息（xml、java注解、java代码）组装所依赖的Bean实例，并将组装出的Bean实例注入到该对象中。Spring中的这个容器控制着所有应用组件（Bean对象）的整个生命周期，从如何产生到如何销毁，而原本这些对象的生命周期都是由其依赖的对象直接控制的，这个容器被叫做控制反转容器，因为它反转了对象的控制权。Spring容器是Spring的核心。</p>\n\n<ul>\n <li>\n  <p><code>org.springframework.beans</code></p></li>\n <li>\n  <p><code>org.springframework.context</code></p></li></ul>\n\n<h3 id=\"应用程序资源spring-resource\">应用程序资源——Spring Resource</h3>\n\n<p>Spring内部自定义的资源：</p>\n\n<ul>\n <li>\n  <p>UrlResource：wraps a <code>java.net.URL</code>, and may be used to access any object that is normally accessible via a URL, such as files, an HTTP target, an FTP target, etc.</p></li>\n <li>ClassPathResource：represents a resource which should be obtained from the classpath.This uses either the thread context class loader, a given class loader, or a given class for loading resources.</li>\n <li>FileSystemResource：a <code>Resource</code> implementation for <code>java.io.File</code> handles. It obviously supports resolution as a <code>File</code>, and as a <code>URL</code>.</li>\n <li>ServletContextResource：a <code>Resource</code> implementation for <code>ServletContext</code> resources, interpreting relative paths within the relevant web application’s root directory</li>\n <li>InputStreamResource：implementation for a given <code>InputStream</code>. This should only be used if no specific <code>Resource</code> implementation is applicable.</li>\n <li>ByteArrayResource：a <code>Resource</code> implementation for a given byte array</li></ul>\n\n<p>资源加载器（ResourceLoader）：</p>\n\n<p>资源加载器用来实现在应用程序中加载资源。 Spring中ResourceLoader接口定义如下所示。 Spring中所用的应用程序上下文都实现了该接口。所以如果在应用程序中想要获取资源，可以通过应用程序上下文来获取。例如applicationContext.getResource(&ldquo;http://myhost.com/resource/path/myTemplate.txt&rdquo;)；</p>\n\n<div class=\"brush: java\">\n <pre><code>public interface ResourceLoader {\n \n    Resource getResource(String location);\n}</code></pre></div>\n\n<h3 id=\"应用程序数据处理验证数据绑定和类型转换\">应用程序数据处理——验证、数据绑定和类型转换</h3>\n\n<h4 id=\"validation\">Validation</h4>\n\n<h4 id=\"data-binding\">Data Binding</h4>\n\n<h4 id=\"type-convertion\">Type Convertion</h4>\n\n<p>Spring 提供了一个通用的类型转换系统,可以用来进行类型之间的转换。其接口定义如下：</p>\n\n<div class=\"brush: java\">\n <pre><code>package org.springframework.core.convert.converter;\n \npublic interface Converter&lt;S, T&gt; {\n \n    T convert(S source);\n \n}</code></pre></div>\n\n<h3 id=\"切面编程spring-aop\">切面编程——Spring AOP</h3>\n\n<h4 id=\"aop原理\">AOP原理</h4>\n\n<h4 id=\"spring-aop中的概念\">Spring AOP中的概念</h4>\n\n<p>AOP框架是Spring的一个关键组件。AOP的应用如权限管理、日志记录、事务的。Spring中AOP的概念：</p>\n\n<ul>\n <li>\n  <p><em>Aspect</em> ：切面，对跨越多个类的关注点的模块化抽象。</p></li>\n <li><em>Join point</em> ：接入点，表示程序执行期间的一个位置，比如程序中某个方法调用前的地方，方法调用异常的地方或者方法调用结束的地方，这些位置可以接入一些切面的行为。</li>\n <li><em>Advice</em> ：表示切面在特殊接入点（join point）的行为。</li>\n <li><em>Pointcut</em> ：切点，对接入点（join point）的匹配预测。Advice 被关联到一个pointcut表达式，它会在匹配 pointcut表达式的任何接入点处执行行。</li>\n <li><em>Introduction</em> ：在一个类型上声明附加的方法和字段</li>\n <li><em>Target object</em> : 目标对象。</li>\n <li><em>AOP proxy</em> ：AOP 框架为实现切面契约而创建的对象，它是Target object的代理对象。</li>\n <li><em>Weaving</em> ：</li></ul>\n\n<p>JDk动态代理实现AOP：</p>\n\n<div class=\"brush: java\">\n <pre><code>public abstract class Aspect implements InvocationHandler {\n \n    private Object target;\n \n    public Aspect(Object target) {\n        this.target = target;\n    }\n \n    /**\n     * Returns target object.\n     */\n    public final Object getTarget() {\n        return this.target;\n    }\n \n    /**\n     * Runs before targets method. Returns {@code true} if target method\n     * should run.\n     */\n    public abstract boolean before(Object target, Method method, Object[] args);\n \n    /**\n     * Runs after targets method. Returns {@code true} if aspect method should\n     * return value, otherwise {@code null}.\n     */\n    public abstract boolean after(Object target, Method method, Object[] args);\n \n    /**\n     * Invoked after exception.\n     */\n    public abstract boolean afterException(Object target, Method method, Object[] args, Throwable throwable);\n \n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        Object result = null;\n \n        if (before(target, method, args)) {\n            try {\n                result = method.invoke(target, args);\n            }\n            catch (InvocationTargetException e) {\n                afterException(args, method, args, e.getTargetException());\n            }\n            catch (Exception ex) {\n                throw ex;\n            }\n        }\n        if (after(target, method, args)) {\n            return result;\n        }\n        return null;\n    }\n \n}</code></pre></div>\n\n<div class=\"brush: java\">\n <pre><code>public class AopProxy {\n \n    /**\n     * Creates a proxy of given target and the aspect.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static &lt;T&gt; T proxyOf(T target, Class&lt;? extends Aspect&gt; aspectClass) {\n        final Aspect aspect;\n \n        try {\n            aspect = ClassUtil.newInstance(aspectClass, target);\n        }\n        catch (Exception e) {\n            throw new IllegalArgumentException(\"Can't create new instance of aspect class\", e);\n        }\n \n        return (T) newProxyInstance(target.getClass().getClassLoader(), aspect, target.getClass().getInterfaces());\n    }\n \n    /**\n     * Creates a proxy from given {@link Aspect}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static &lt;T&gt; T proxyOf(Aspect aspect) {\n        final Object target = aspect.getTarget();\n        return (T) newProxyInstance(target.getClass().getClassLoader(), aspect, target.getClass().getInterfaces());\n    }\n \n    /**\n     * Simple wrapper for javas {@code newProxyInstance}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static &lt;T&gt; T newProxyInstance(ClassLoader classloader, InvocationHandler invocationHandler, Class&lt;?&gt;... interfaces) {\n        if (interfaces.length == 0) {\n            throw new IllegalArgumentException(\"No interfaces of target class found.\");\n        }\n        return (T) Proxy.newProxyInstance(classloader, interfaces, invocationHandler);\n    }\n \n}\n </code></pre></div>\n\n<h3 id=\"spring事务\">Spring事务</h3>\n\n<h3 id=\"springmvc\">SpringMVC</h3>") #f (u . "\n<p>[TOC]</p>\n\n<h1 id=\"spring\">Spring</h1>\n\n<blockquote>\n <p>Spring 参考文档</p>\n <p>Spring core</p>\n <p>https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html</p>\n <p>Spring mvc</p></blockquote>\n\n<p>Sping将程序看成由各个组件相互组装而成，<code>抽象出组件和组装组件的容器</code>。应用程序中通过组件的配置信息（xml、java注解、java代码）告诉容器如何初始化、配置和组件组件，Spring扫描配置信息，然后按照配置信息组装出程序。这就是Spring的核心原理。</p>\n\n<div class=\"figure\"><img src=\"C:UsersGnailyAppDataLocalTemp1523797001169.png\" alt=\"1523797001169\" />\n <p class=\"caption\">1523797001169</p></div>\n\n<h3 id=\"应用程序组件的表示spring-bean\">应用程序组件的表示——Spring Bean</h3>\n\n<p>Spring使用Bean来表示应用程序组件，在Spring中每一个应用程序组件都是一个Bean实体。Spring的Bean可以是任何形式的POJO。</p>\n\n<p>Bean的作用域：</p>\n\n<p>| Scope | Description | | &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; | &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; | | <a href=\"https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-singleton\">singleton</a> | (Default) Scopes a single bean definition to a single object instance per Spring IoC container. | | <a href=\"https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-prototype\">prototype</a> | Scopes a single bean definition to any number of object instances. | | <a href=\"https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-request\">request</a> | Scopes a single bean definition to the lifecycle of a single HTTP request; that is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>. | | <a href=\"https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-session\">session</a> | Scopes a single bean definition to the lifecycle of an HTTP <code>Session</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>. | | <a href=\"https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-application\">application</a> | Scopes a single bean definition to the lifecycle of a <code>ServletContext</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>. | | <a href=\"https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/web.html#websocket-stomp-websocket-scope\">websocket</a> | Scopes a single bean definition to the lifecycle of a <code>WebSocket</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>. |</p>\n\n<p>Bean的配置：</p>\n\n<p>xml配置Bean：在xml文件中配置一个Bean时，用一个唯一的id来标识这个Bean,用class指定该Bean的类的全限定名（包名.类名）。</p>\n\n<div class=\"brush: xml\">\n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;\n \n    &lt;bean id=\"...\" class=\"...\"&gt;\n        &lt;!-- collaborators and configuration for this bean go here --&gt;\n    &lt;/bean&gt;\n \n    &lt;bean id=\"...\" class=\"...\"&gt;\n        &lt;!-- collaborators and configuration for this bean go here --&gt;\n \n    &lt;!-- more bean definitions go here --&gt;\n \n&lt;/beans&gt;</code></pre></div>\n\n<p>注解配置Bean：在POJO的类上添加@Bean注解。</p>\n\n<h3 id=\"应用程序组件的组装spring-依赖注入与控制反转\">应用程序组件的组装——Spring 依赖注入与控制反转</h3>\n\n<h4 id=\"依赖注入dependency-injection\">依赖注入（Dependency Injection）</h4>\n\n<p>一个对象不在自己的内部构造出它所依赖的对象，它所依赖的对象由第三方构造然后通过该对象的<code>构造方法</code>或者<code>setter方法</code>注入进来。</p>\n\n<h4 id=\"控制反转容器ioc-container\">控制反转容器（IoC Container）</h4>\n\n<p>Spring通过一个容器来根据一个对象的配置信息（xml、java注解、java代码）组装所依赖的Bean实例，并将组装出的Bean实例注入到该对象中。Spring中的这个容器控制着所有应用组件（Bean对象）的整个生命周期，从如何产生到如何销毁，而原本这些对象的生命周期都是由其依赖的对象直接控制的，这个容器被叫做控制反转容器，因为它反转了对象的控制权。Spring容器是Spring的核心。</p>\n\n<ul>\n <li>\n  <p><code>org.springframework.beans</code></p></li>\n <li>\n  <p><code>org.springframework.context</code></p></li></ul>\n\n<h3 id=\"应用程序资源spring-resource\">应用程序资源——Spring Resource</h3>\n\n<p>Spring内部自定义的资源：</p>\n\n<ul>\n <li>\n  <p>UrlResource：wraps a <code>java.net.URL</code>, and may be used to access any object that is normally accessible via a URL, such as files, an HTTP target, an FTP target, etc.</p></li>\n <li>ClassPathResource：represents a resource which should be obtained from the classpath.This uses either the thread context class loader, a given class loader, or a given class for loading resources.</li>\n <li>FileSystemResource：a <code>Resource</code> implementation for <code>java.io.File</code> handles. It obviously supports resolution as a <code>File</code>, and as a <code>URL</code>.</li>\n <li>ServletContextResource：a <code>Resource</code> implementation for <code>ServletContext</code> resources, interpreting relative paths within the relevant web application’s root directory</li>\n <li>InputStreamResource：implementation for a given <code>InputStream</code>. This should only be used if no specific <code>Resource</code> implementation is applicable.</li>\n <li>ByteArrayResource：a <code>Resource</code> implementation for a given byte array</li></ul>\n\n<p>资源加载器（ResourceLoader）：</p>\n\n<p>资源加载器用来实现在应用程序中加载资源。 Spring中ResourceLoader接口定义如下所示。 Spring中所用的应用程序上下文都实现了该接口。所以如果在应用程序中想要获取资源，可以通过应用程序上下文来获取。例如applicationContext.getResource(&ldquo;http://myhost.com/resource/path/myTemplate.txt&rdquo;)；</p>\n\n<div class=\"brush: java\">\n <pre><code>public interface ResourceLoader {\n \n    Resource getResource(String location);\n}</code></pre></div>\n\n<h3 id=\"应用程序数据处理验证数据绑定和类型转换\">应用程序数据处理——验证、数据绑定和类型转换</h3>\n\n<h4 id=\"validation\">Validation</h4>\n\n<h4 id=\"data-binding\">Data Binding</h4>\n\n<h4 id=\"type-convertion\">Type Convertion</h4>\n\n<p>Spring 提供了一个通用的类型转换系统,可以用来进行类型之间的转换。其接口定义如下：</p>\n\n<div class=\"brush: java\">\n <pre><code>package org.springframework.core.convert.converter;\n \npublic interface Converter&lt;S, T&gt; {\n \n    T convert(S source);\n \n}</code></pre></div>\n\n<h3 id=\"切面编程spring-aop\">切面编程——Spring AOP</h3>\n\n<h4 id=\"aop原理\">AOP原理</h4>\n\n<h4 id=\"spring-aop中的概念\">Spring AOP中的概念</h4>\n\n<p>AOP框架是Spring的一个关键组件。AOP的应用如权限管理、日志记录、事务的。Spring中AOP的概念：</p>\n\n<ul>\n <li>\n  <p><em>Aspect</em> ：切面，对跨越多个类的关注点的模块化抽象。</p></li>\n <li><em>Join point</em> ：接入点，表示程序执行期间的一个位置，比如程序中某个方法调用前的地方，方法调用异常的地方或者方法调用结束的地方，这些位置可以接入一些切面的行为。</li>\n <li><em>Advice</em> ：表示切面在特殊接入点（join point）的行为。</li>\n <li><em>Pointcut</em> ：切点，对接入点（join point）的匹配预测。Advice 被关联到一个pointcut表达式，它会在匹配 pointcut表达式的任何接入点处执行行。</li>\n <li><em>Introduction</em> ：在一个类型上声明附加的方法和字段</li>\n <li><em>Target object</em> : 目标对象。</li>\n <li><em>AOP proxy</em> ：AOP 框架为实现切面契约而创建的对象，它是Target object的代理对象。</li>\n <li><em>Weaving</em> ：</li></ul>\n\n<p>JDk动态代理实现AOP：</p>\n\n<div class=\"brush: java\">\n <pre><code>public abstract class Aspect implements InvocationHandler {\n \n    private Object target;\n \n    public Aspect(Object target) {\n        this.target = target;\n    }\n \n    /**\n     * Returns target object.\n     */\n    public final Object getTarget() {\n        return this.target;\n    }\n \n    /**\n     * Runs before targets method. Returns {@code true} if target method\n     * should run.\n     */\n    public abstract boolean before(Object target, Method method, Object[] args);\n \n    /**\n     * Runs after targets method. Returns {@code true} if aspect method should\n     * return value, otherwise {@code null}.\n     */\n    public abstract boolean after(Object target, Method method, Object[] args);\n \n    /**\n     * Invoked after exception.\n     */\n    public abstract boolean afterException(Object target, Method method, Object[] args, Throwable throwable);\n \n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        Object result = null;\n \n        if (before(target, method, args)) {\n            try {\n                result = method.invoke(target, args);\n            }\n            catch (InvocationTargetException e) {\n                afterException(args, method, args, e.getTargetException());\n            }\n            catch (Exception ex) {\n                throw ex;\n            }\n        }\n        if (after(target, method, args)) {\n            return result;\n        }\n        return null;\n    }\n \n}</code></pre></div>\n\n<div class=\"brush: java\">\n <pre><code>public class AopProxy {\n \n    /**\n     * Creates a proxy of given target and the aspect.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static &lt;T&gt; T proxyOf(T target, Class&lt;? extends Aspect&gt; aspectClass) {\n        final Aspect aspect;\n \n        try {\n            aspect = ClassUtil.newInstance(aspectClass, target);\n        }\n        catch (Exception e) {\n            throw new IllegalArgumentException(\"Can't create new instance of aspect class\", e);\n        }\n \n        return (T) newProxyInstance(target.getClass().getClassLoader(), aspect, target.getClass().getInterfaces());\n    }\n \n    /**\n     * Creates a proxy from given {@link Aspect}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static &lt;T&gt; T proxyOf(Aspect aspect) {\n        final Object target = aspect.getTarget();\n        return (T) newProxyInstance(target.getClass().getClassLoader(), aspect, target.getClass().getInterfaces());\n    }\n \n    /**\n     * Simple wrapper for javas {@code newProxyInstance}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static &lt;T&gt; T newProxyInstance(ClassLoader classloader, InvocationHandler invocationHandler, Class&lt;?&gt;... interfaces) {\n        if (interfaces.length == 0) {\n            throw new IllegalArgumentException(\"No interfaces of target class found.\");\n        }\n        return (T) Proxy.newProxyInstance(classloader, interfaces, invocationHandler);\n    }\n \n}\n </code></pre></div>\n\n<h3 id=\"spring事务\">Spring事务</h3>\n\n<h3 id=\"springmvc\">SpringMVC</h3>"))))