((3) 0 () 0 () () (h ! (equal) ((p+ #"E:\\Documents\\Racket\\Gnaily-s-blog\\_src\\posts\\2018-09-30-spring-framwork.md" . windows) f post (u . "Spring Framework") (p+ #"E:\\Documents\\Racket\\Gnaily-s-blog\\_src\\posts\\2018-09-30-spring-framwork.md" . windows) 1548857645 (p+ #"E:\\Documents\\Racket\\Gnaily-s-blog\\2018/09/spring-framework.html" . windows) (u . "/2018\\09\\spring-framework.html") (u . "2018-09-01T00:00:00") #f #f (c (u . "Web") c (u . "Spring")) (u . "\n<p>[TOC]</p>\n\n<h1 id=\"spring\">Spring</h1>\n\n<blockquote>\n <p>Spring 参考文档</p>\n <p>Spring core</p>\n <p>https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html</p>\n <p>Spring mvc</p></blockquote>\n\n<p>Sping将程序看成由各个组件相互组装而成，<code>抽象出组件和组装组件的容器</code>。应用程序中通过组件的配置信息（xml、java注解、java代码）告诉容器如何初始化、配置和组件组件，Spring扫描配置信息，然后按照配置信息组装出程序。这就是Spring的核心原理。</p>\n\n<div class=\"figure\"><img src=\"C:UsersGnailyAppDataLocalTemp1523797001169.png\" alt=\"1523797001169\" />\n <p class=\"caption\">1523797001169</p></div>\n\n<h3 id=\"应用程序组件的表示spring-bean\">应用程序组件的表示——Spring Bean</h3>\n\n<p>Spring使用Bean来表示应用程序组件，在Spring中每一个应用程序组件都是一个Bean实体。Spring的Bean可以是任何形式的POJO。</p>\n\n<p>Bean的作用域：</p>\n\n<p>| Scope | Description | | &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; | &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; | | <a href=\"https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-singleton\">singleton</a> | (Default) Scopes a single bean definition to a single object instance per Spring IoC container. | | <a href=\"https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-prototype\">prototype</a> | Scopes a single bean definition to any number of object instances. | | <a href=\"https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-request\">request</a> | Scopes a single bean definition to the lifecycle of a single HTTP request; that is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>. | | <a href=\"https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-session\">session</a> | Scopes a single bean definition to the lifecycle of an HTTP <code>Session</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>. | | <a href=\"https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-application\">application</a> | Scopes a single bean definition to the lifecycle of a <code>ServletContext</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>. | | <a href=\"https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/web.html#websocket-stomp-websocket-scope\">websocket</a> | Scopes a single bean definition to the lifecycle of a <code>WebSocket</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>. |</p>\n\n<p>Bean的配置：</p>\n\n<p>xml配置Bean：在xml文件中配置一个Bean时，用一个唯一的id来标识这个Bean,用class指定该Bean的类的全限定名（包名.类名）。</p>\n\n<div class=\"brush: xml\">\n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;\n \n    &lt;bean id=\"...\" class=\"...\"&gt;\n        &lt;!-- collaborators and configuration for this bean go here --&gt;\n    &lt;/bean&gt;\n \n    &lt;bean id=\"...\" class=\"...\"&gt;\n        &lt;!-- collaborators and configuration for this bean go here --&gt;\n \n    &lt;!-- more bean definitions go here --&gt;\n \n&lt;/beans&gt;</code></pre></div>\n\n<p>注解配置Bean：在POJO的类上添加@Bean注解。</p>\n\n<h3 id=\"应用程序组件的组装spring-依赖注入与控制反转\">应用程序组件的组装——Spring 依赖注入与控制反转</h3>\n\n<h4 id=\"依赖注入dependency-injection\">依赖注入（Dependency Injection）</h4>\n\n<p>一个对象不在自己的内部构造出它所依赖的对象，它所依赖的对象由第三方构造然后通过该对象的<code>构造方法</code>或者<code>setter方法</code>注入进来。</p>\n\n<h4 id=\"控制反转容器ioc-container\">控制反转容器（IoC Container）</h4>\n\n<p>Spring通过一个容器来根据一个对象的配置信息（xml、java注解、java代码）组装所依赖的Bean实例，并将组装出的Bean实例注入到该对象中。Spring中的这个容器控制着所有应用组件（Bean对象）的整个生命周期，从如何产生到如何销毁，而原本这些对象的生命周期都是由其依赖的对象直接控制的，这个容器被叫做控制反转容器，因为它反转了对象的控制权。Spring容器是Spring的核心。</p>\n\n<ul>\n <li>\n  <p><code>org.springframework.beans</code></p></li>\n <li>\n  <p><code>org.springframework.context</code></p></li></ul>\n\n<h3 id=\"应用程序资源spring-resource\">应用程序资源——Spring Resource</h3>\n\n<p>Spring内部自定义的资源：</p>\n\n<ul>\n <li>\n  <p>UrlResource：wraps a <code>java.net.URL</code>, and may be used to access any object that is normally accessible via a URL, such as files, an HTTP target, an FTP target, etc.</p></li>\n <li>ClassPathResource：represents a resource which should be obtained from the classpath.This uses either the thread context class loader, a given class loader, or a given class for loading resources.</li>\n <li>FileSystemResource：a <code>Resource</code> implementation for <code>java.io.File</code> handles. It obviously supports resolution as a <code>File</code>, and as a <code>URL</code>.</li>\n <li>ServletContextResource：a <code>Resource</code> implementation for <code>ServletContext</code> resources, interpreting relative paths within the relevant web application’s root directory</li>\n <li>InputStreamResource：implementation for a given <code>InputStream</code>. This should only be used if no specific <code>Resource</code> implementation is applicable.</li>\n <li>ByteArrayResource：a <code>Resource</code> implementation for a given byte array</li></ul>\n\n<p>资源加载器（ResourceLoader）：</p>\n\n<p>资源加载器用来实现在应用程序中加载资源。 Spring中ResourceLoader接口定义如下所示。 Spring中所用的应用程序上下文都实现了该接口。所以如果在应用程序中想要获取资源，可以通过应用程序上下文来获取。例如applicationContext.getResource(&ldquo;http://myhost.com/resource/path/myTemplate.txt&rdquo;)；</p>\n\n<div class=\"brush: java\">\n <pre><code>public interface ResourceLoader {\n \n    Resource getResource(String location);\n}</code></pre></div>\n\n<h3 id=\"应用程序数据处理验证数据绑定和类型转换\">应用程序数据处理——验证、数据绑定和类型转换</h3>\n\n<h4 id=\"validation\">Validation</h4>\n\n<h4 id=\"data-binding\">Data Binding</h4>\n\n<h4 id=\"type-convertion\">Type Convertion</h4>\n\n<p>Spring 提供了一个通用的类型转换系统,可以用来进行类型之间的转换。其接口定义如下：</p>\n\n<div class=\"brush: java\">\n <pre><code>package org.springframework.core.convert.converter;\n \npublic interface Converter&lt;S, T&gt; {\n \n    T convert(S source);\n \n}</code></pre></div>\n\n<h3 id=\"切面编程spring-aop\">切面编程——Spring AOP</h3>\n\n<h4 id=\"aop原理\">AOP原理</h4>\n\n<h4 id=\"spring-aop中的概念\">Spring AOP中的概念</h4>\n\n<p>AOP框架是Spring的一个关键组件。AOP的应用如权限管理、日志记录、事务的。Spring中AOP的概念：</p>\n\n<ul>\n <li>\n  <p><em>Aspect</em> ：切面，对跨越多个类的关注点的模块化抽象。</p></li>\n <li><em>Join point</em> ：接入点，表示程序执行期间的一个位置，比如程序中某个方法调用前的地方，方法调用异常的地方或者方法调用结束的地方，这些位置可以接入一些切面的行为。</li>\n <li><em>Advice</em> ：表示切面在特殊接入点（join point）的行为。</li>\n <li><em>Pointcut</em> ：切点，对接入点（join point）的匹配预测。Advice 被关联到一个pointcut表达式，它会在匹配 pointcut表达式的任何接入点处执行行。</li>\n <li><em>Introduction</em> ：在一个类型上声明附加的方法和字段</li>\n <li><em>Target object</em> : 目标对象。</li>\n <li><em>AOP proxy</em> ：AOP 框架为实现切面契约而创建的对象，它是Target object的代理对象。</li>\n <li><em>Weaving</em> ：</li></ul>\n\n<p>JDk动态代理实现AOP：</p>\n\n<div class=\"brush: java\">\n <pre><code>public abstract class Aspect implements InvocationHandler {\n \n    private Object target;\n \n    public Aspect(Object target) {\n        this.target = target;\n    }\n \n    /**\n     * Returns target object.\n     */\n    public final Object getTarget() {\n        return this.target;\n    }\n \n    /**\n     * Runs before targets method. Returns {@code true} if target method\n     * should run.\n     */\n    public abstract boolean before(Object target, Method method, Object[] args);\n \n    /**\n     * Runs after targets method. Returns {@code true} if aspect method should\n     * return value, otherwise {@code null}.\n     */\n    public abstract boolean after(Object target, Method method, Object[] args);\n \n    /**\n     * Invoked after exception.\n     */\n    public abstract boolean afterException(Object target, Method method, Object[] args, Throwable throwable);\n \n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        Object result = null;\n \n        if (before(target, method, args)) {\n            try {\n                result = method.invoke(target, args);\n            }\n            catch (InvocationTargetException e) {\n                afterException(args, method, args, e.getTargetException());\n            }\n            catch (Exception ex) {\n                throw ex;\n            }\n        }\n        if (after(target, method, args)) {\n            return result;\n        }\n        return null;\n    }\n \n}</code></pre></div>\n\n<div class=\"brush: java\">\n <pre><code>public class AopProxy {\n \n    /**\n     * Creates a proxy of given target and the aspect.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static &lt;T&gt; T proxyOf(T target, Class&lt;? extends Aspect&gt; aspectClass) {\n        final Aspect aspect;\n \n        try {\n            aspect = ClassUtil.newInstance(aspectClass, target);\n        }\n        catch (Exception e) {\n            throw new IllegalArgumentException(\"Can't create new instance of aspect class\", e);\n        }\n \n        return (T) newProxyInstance(target.getClass().getClassLoader(), aspect, target.getClass().getInterfaces());\n    }\n \n    /**\n     * Creates a proxy from given {@link Aspect}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static &lt;T&gt; T proxyOf(Aspect aspect) {\n        final Object target = aspect.getTarget();\n        return (T) newProxyInstance(target.getClass().getClassLoader(), aspect, target.getClass().getInterfaces());\n    }\n \n    /**\n     * Simple wrapper for javas {@code newProxyInstance}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static &lt;T&gt; T newProxyInstance(ClassLoader classloader, InvocationHandler invocationHandler, Class&lt;?&gt;... interfaces) {\n        if (interfaces.length == 0) {\n            throw new IllegalArgumentException(\"No interfaces of target class found.\");\n        }\n        return (T) Proxy.newProxyInstance(classloader, interfaces, invocationHandler);\n    }\n \n}\n </code></pre></div>\n\n<h3 id=\"spring事务\">Spring事务</h3>\n\n<h3 id=\"springmvc\">SpringMVC</h3>") #f (u . "\n<p>[TOC]</p>\n\n<h1 id=\"spring\">Spring</h1>\n\n<blockquote>\n <p>Spring 参考文档</p>\n <p>Spring core</p>\n <p>https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html</p>\n <p>Spring mvc</p></blockquote>\n\n<p>Sping将程序看成由各个组件相互组装而成，<code>抽象出组件和组装组件的容器</code>。应用程序中通过组件的配置信息（xml、java注解、java代码）告诉容器如何初始化、配置和组件组件，Spring扫描配置信息，然后按照配置信息组装出程序。这就是Spring的核心原理。</p>\n\n<div class=\"figure\"><img src=\"C:UsersGnailyAppDataLocalTemp1523797001169.png\" alt=\"1523797001169\" />\n <p class=\"caption\">1523797001169</p></div>\n\n<h3 id=\"应用程序组件的表示spring-bean\">应用程序组件的表示——Spring Bean</h3>\n\n<p>Spring使用Bean来表示应用程序组件，在Spring中每一个应用程序组件都是一个Bean实体。Spring的Bean可以是任何形式的POJO。</p>\n\n<p>Bean的作用域：</p>\n\n<p>| Scope | Description | | &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; | &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; | | <a href=\"https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-singleton\">singleton</a> | (Default) Scopes a single bean definition to a single object instance per Spring IoC container. | | <a href=\"https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-prototype\">prototype</a> | Scopes a single bean definition to any number of object instances. | | <a href=\"https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-request\">request</a> | Scopes a single bean definition to the lifecycle of a single HTTP request; that is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>. | | <a href=\"https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-session\">session</a> | Scopes a single bean definition to the lifecycle of an HTTP <code>Session</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>. | | <a href=\"https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-application\">application</a> | Scopes a single bean definition to the lifecycle of a <code>ServletContext</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>. | | <a href=\"https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/web.html#websocket-stomp-websocket-scope\">websocket</a> | Scopes a single bean definition to the lifecycle of a <code>WebSocket</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>. |</p>\n\n<p>Bean的配置：</p>\n\n<p>xml配置Bean：在xml文件中配置一个Bean时，用一个唯一的id来标识这个Bean,用class指定该Bean的类的全限定名（包名.类名）。</p>\n\n<div class=\"brush: xml\">\n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;\n \n    &lt;bean id=\"...\" class=\"...\"&gt;\n        &lt;!-- collaborators and configuration for this bean go here --&gt;\n    &lt;/bean&gt;\n \n    &lt;bean id=\"...\" class=\"...\"&gt;\n        &lt;!-- collaborators and configuration for this bean go here --&gt;\n \n    &lt;!-- more bean definitions go here --&gt;\n \n&lt;/beans&gt;</code></pre></div>\n\n<p>注解配置Bean：在POJO的类上添加@Bean注解。</p>\n\n<h3 id=\"应用程序组件的组装spring-依赖注入与控制反转\">应用程序组件的组装——Spring 依赖注入与控制反转</h3>\n\n<h4 id=\"依赖注入dependency-injection\">依赖注入（Dependency Injection）</h4>\n\n<p>一个对象不在自己的内部构造出它所依赖的对象，它所依赖的对象由第三方构造然后通过该对象的<code>构造方法</code>或者<code>setter方法</code>注入进来。</p>\n\n<h4 id=\"控制反转容器ioc-container\">控制反转容器（IoC Container）</h4>\n\n<p>Spring通过一个容器来根据一个对象的配置信息（xml、java注解、java代码）组装所依赖的Bean实例，并将组装出的Bean实例注入到该对象中。Spring中的这个容器控制着所有应用组件（Bean对象）的整个生命周期，从如何产生到如何销毁，而原本这些对象的生命周期都是由其依赖的对象直接控制的，这个容器被叫做控制反转容器，因为它反转了对象的控制权。Spring容器是Spring的核心。</p>\n\n<ul>\n <li>\n  <p><code>org.springframework.beans</code></p></li>\n <li>\n  <p><code>org.springframework.context</code></p></li></ul>\n\n<h3 id=\"应用程序资源spring-resource\">应用程序资源——Spring Resource</h3>\n\n<p>Spring内部自定义的资源：</p>\n\n<ul>\n <li>\n  <p>UrlResource：wraps a <code>java.net.URL</code>, and may be used to access any object that is normally accessible via a URL, such as files, an HTTP target, an FTP target, etc.</p></li>\n <li>ClassPathResource：represents a resource which should be obtained from the classpath.This uses either the thread context class loader, a given class loader, or a given class for loading resources.</li>\n <li>FileSystemResource：a <code>Resource</code> implementation for <code>java.io.File</code> handles. It obviously supports resolution as a <code>File</code>, and as a <code>URL</code>.</li>\n <li>ServletContextResource：a <code>Resource</code> implementation for <code>ServletContext</code> resources, interpreting relative paths within the relevant web application’s root directory</li>\n <li>InputStreamResource：implementation for a given <code>InputStream</code>. This should only be used if no specific <code>Resource</code> implementation is applicable.</li>\n <li>ByteArrayResource：a <code>Resource</code> implementation for a given byte array</li></ul>\n\n<p>资源加载器（ResourceLoader）：</p>\n\n<p>资源加载器用来实现在应用程序中加载资源。 Spring中ResourceLoader接口定义如下所示。 Spring中所用的应用程序上下文都实现了该接口。所以如果在应用程序中想要获取资源，可以通过应用程序上下文来获取。例如applicationContext.getResource(&ldquo;http://myhost.com/resource/path/myTemplate.txt&rdquo;)；</p>\n\n<div class=\"brush: java\">\n <pre><code>public interface ResourceLoader {\n \n    Resource getResource(String location);\n}</code></pre></div>\n\n<h3 id=\"应用程序数据处理验证数据绑定和类型转换\">应用程序数据处理——验证、数据绑定和类型转换</h3>\n\n<h4 id=\"validation\">Validation</h4>\n\n<h4 id=\"data-binding\">Data Binding</h4>\n\n<h4 id=\"type-convertion\">Type Convertion</h4>\n\n<p>Spring 提供了一个通用的类型转换系统,可以用来进行类型之间的转换。其接口定义如下：</p>\n\n<div class=\"brush: java\">\n <pre><code>package org.springframework.core.convert.converter;\n \npublic interface Converter&lt;S, T&gt; {\n \n    T convert(S source);\n \n}</code></pre></div>\n\n<h3 id=\"切面编程spring-aop\">切面编程——Spring AOP</h3>\n\n<h4 id=\"aop原理\">AOP原理</h4>\n\n<h4 id=\"spring-aop中的概念\">Spring AOP中的概念</h4>\n\n<p>AOP框架是Spring的一个关键组件。AOP的应用如权限管理、日志记录、事务的。Spring中AOP的概念：</p>\n\n<ul>\n <li>\n  <p><em>Aspect</em> ：切面，对跨越多个类的关注点的模块化抽象。</p></li>\n <li><em>Join point</em> ：接入点，表示程序执行期间的一个位置，比如程序中某个方法调用前的地方，方法调用异常的地方或者方法调用结束的地方，这些位置可以接入一些切面的行为。</li>\n <li><em>Advice</em> ：表示切面在特殊接入点（join point）的行为。</li>\n <li><em>Pointcut</em> ：切点，对接入点（join point）的匹配预测。Advice 被关联到一个pointcut表达式，它会在匹配 pointcut表达式的任何接入点处执行行。</li>\n <li><em>Introduction</em> ：在一个类型上声明附加的方法和字段</li>\n <li><em>Target object</em> : 目标对象。</li>\n <li><em>AOP proxy</em> ：AOP 框架为实现切面契约而创建的对象，它是Target object的代理对象。</li>\n <li><em>Weaving</em> ：</li></ul>\n\n<p>JDk动态代理实现AOP：</p>\n\n<div class=\"brush: java\">\n <pre><code>public abstract class Aspect implements InvocationHandler {\n \n    private Object target;\n \n    public Aspect(Object target) {\n        this.target = target;\n    }\n \n    /**\n     * Returns target object.\n     */\n    public final Object getTarget() {\n        return this.target;\n    }\n \n    /**\n     * Runs before targets method. Returns {@code true} if target method\n     * should run.\n     */\n    public abstract boolean before(Object target, Method method, Object[] args);\n \n    /**\n     * Runs after targets method. Returns {@code true} if aspect method should\n     * return value, otherwise {@code null}.\n     */\n    public abstract boolean after(Object target, Method method, Object[] args);\n \n    /**\n     * Invoked after exception.\n     */\n    public abstract boolean afterException(Object target, Method method, Object[] args, Throwable throwable);\n \n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        Object result = null;\n \n        if (before(target, method, args)) {\n            try {\n                result = method.invoke(target, args);\n            }\n            catch (InvocationTargetException e) {\n                afterException(args, method, args, e.getTargetException());\n            }\n            catch (Exception ex) {\n                throw ex;\n            }\n        }\n        if (after(target, method, args)) {\n            return result;\n        }\n        return null;\n    }\n \n}</code></pre></div>\n\n<div class=\"brush: java\">\n <pre><code>public class AopProxy {\n \n    /**\n     * Creates a proxy of given target and the aspect.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static &lt;T&gt; T proxyOf(T target, Class&lt;? extends Aspect&gt; aspectClass) {\n        final Aspect aspect;\n \n        try {\n            aspect = ClassUtil.newInstance(aspectClass, target);\n        }\n        catch (Exception e) {\n            throw new IllegalArgumentException(\"Can't create new instance of aspect class\", e);\n        }\n \n        return (T) newProxyInstance(target.getClass().getClassLoader(), aspect, target.getClass().getInterfaces());\n    }\n \n    /**\n     * Creates a proxy from given {@link Aspect}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static &lt;T&gt; T proxyOf(Aspect aspect) {\n        final Object target = aspect.getTarget();\n        return (T) newProxyInstance(target.getClass().getClassLoader(), aspect, target.getClass().getInterfaces());\n    }\n \n    /**\n     * Simple wrapper for javas {@code newProxyInstance}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static &lt;T&gt; T newProxyInstance(ClassLoader classloader, InvocationHandler invocationHandler, Class&lt;?&gt;... interfaces) {\n        if (interfaces.length == 0) {\n            throw new IllegalArgumentException(\"No interfaces of target class found.\");\n        }\n        return (T) Proxy.newProxyInstance(classloader, interfaces, invocationHandler);\n    }\n \n}\n </code></pre></div>\n\n<h3 id=\"spring事务\">Spring事务</h3>\n\n<h3 id=\"springmvc\">SpringMVC</h3>"))))